%{
// Includes the definition of symbolic tokens. The enum definition in this
// header file replaces the `enum Token {...}` you wrote in project 1.
// It also includes the declaration of the global variable `yylval` which will
// be used by code generated by Yacc/Bison.
//
// This header file is generated by Yacc/Bison from parser.y. We suggest that
// you take a look at the content of this header file - it's not long.
#include "../cmake-build-debug/parser.h"

#include <stdio.h>
#include <stdlib.h>
extern int yylex();
%}

%option yylineno

%%

"//".*                                              { }                                 /* inline comments */
\/\*([^/*]|\*[^/]|[^*]\/)*\*\/                      { }                                 /* block comments */



boolean               { return KW_BOOLEAN;            }
class                 { return KW_CLASS;              }
false                 { return KW_FALSE;              }
true                 { return KW_TRUE;              }
int                   { return KW_INT;                }
new                   { return KW_NEW;                }
main                  { return MAIN;                  }
public                { return KW_PUBLIC;             }
private               { return KW_PRIVATE;            }
static                { return KW_STATIC;             }
String                { return KW_STRING;             }
System\.out\.print    { return SYSTEM_OUT_PRINT;      }
System\.out\.println  { return SYSTEM_OUT_PRINTLN;    }
Integer\.parseInt     { return INTEGER_PARSEINT;      }
void                  { return KW_VOID;               }
\.length              { return KW_LENGTH;             }

if                    { return KW_IF;                 }
else                  { return KW_ELSE;               }
while                 { return KW_WHILE;              }
return                { return KW_RETURN;             }

"||"                  { return KW_SHORTCIRCUITOR;     }
"&&"                  { return KW_SHORTCIRCUITAND;    }
"=="                  { return KW_COMPARISONEQUALS;   }
"!="                  { return KW_NOTEQUALS;          }
"<="                  { return KW_LESSTHANEQUALS;     }
">="                  { return KW_GREATERTHANEQUALS;  }
"{"                   { return '{';                   }
"}"                   { return '}';                   }
"("                   { return '(';                   }
")"                   { return ')';                   }
"["                 { return '['; }
"]"                 { return ']'; }
";"                   { return ';';                   }
"="                   { return '=';                   }
"+"                 { return '+'; }
"-"                   { return '-';                   }
"*"                   { return '*';                   }
"/"                   { return '/';                   }
"!"                   { return '!';                   }
"."                   { return '.';                   }
","                   { return ',';                   }
">"                    { return '>';                  }
"<"                     { return '<';                 }







[0-9]+ {
    yylval.integer = atoi(strdup(yytext));
    return INTEGER_LITERAL;
}

[a-zA-Z][a-zA-Z0-9_]* {
    yylval.string = strdup(yytext);
    return ID;                 
}

\"([^"\\]|\\.)*\" {
    yylval.string = strdup(yytext);
    return STRING_LITERAL;                    
}

[ \t\n]               { } /* skip whitespace */

%%

int yywrap(void) {
    return 1;
}
//
// Created by Evan Shaw on 4/25/23.
//

#include "MethodCallExpASTNode.h"
#include "../../Instruction/MoveInstruction.h"
#include "../../Instruction/BranchLinkInstruction.h"

#include <utility>
#include <iostream>

MethodCallExpASTNode::MethodCallExpASTNode(FunctionSymbolTableEntry *function_reference_to_symtab_entry,
                                           std::vector<ExpASTNode *> arg_exp_list) : function_reference_to_symtab_entry(
		function_reference_to_symtab_entry), arg_exp_list(std::move(arg_exp_list)) {

}

std::vector<Instruction *> MethodCallExpASTNode::gen_3AC(int *symbolic_register_counter) {
	//TODO: this method should populate a private field that tells what registers it uses so that we know what to caller save

	//TODO: also might want to put a reference from the call instruction generated by this method, to the first instruction
	//TODO: that starts to set up a method call's registers

	auto instr_list = std::vector<Instruction *>();
	int expression_returned_r0 = 0;
	auto final_operand_list = std::vector<Operand>();
	//loop through the argument list and append each instruction's output operand to this list ^
	for (ExpASTNode *i : arg_exp_list) {
		auto stmt_instr_list = i->gen_3AC(symbolic_register_counter);
		instr_list.insert(instr_list.end(), stmt_instr_list.begin(), stmt_instr_list.end());
		//if there is more than one methodcall or something else on the explist that leaves its value in a register
		//then we need to emit an instruction to store it to an intermediate, then put that intermediate on the list
		//TODO: this part is untested
		Operand exp_output_operand = i->get_output_operand();
		if (exp_output_operand.getOperandType() == OPERAND_TYPE_REGISTER) {
			if (exp_output_operand.getOperandValue() == 0) {
				if (expression_returned_r0 == 0) {
					//just increment, don't have to do anything else
					expression_returned_r0++;
				} else {
					//ok now we have to modify the operand
					Operand destination_replacement_operand = Operand(OPERAND_TYPE_SYMBOLIC_REGISTER, (*symbolic_register_counter)++);
					Operand source_r0 = Operand(OPERAND_TYPE_REGISTER, 0);
					//emit instruction moving into replacement symbolic
					auto *mov_replacement = new MoveInstruction(destination_replacement_operand, source_r0);
					//put replacement on the list
					final_operand_list.push_back(destination_replacement_operand);
					//add instruction to its own list
					instr_list.push_back(mov_replacement);
					continue;
				}
			} else {
				std::cout << "SOME ARGUMENT OF A METHOD CALL IS EVALUATING IN A REGISTER OTHER THAN R0" << std::endl;
			}
		}
		final_operand_list.push_back(exp_output_operand);
	}

	//here is where we should maybe handle saving registers in use, or should that be done in register allocation???

	int arg_index = 0;
	for (const Operand &source : final_operand_list) {
		//assign the first four args to registers r0-r3
		if (arg_index < 4) {
			Operand destination = Operand(OPERAND_TYPE_REGISTER, arg_index);
			auto mov_instr = new MoveInstruction(destination, source);
			instr_list.push_back(mov_instr);
			arg_index++;
		} else {
			std::cout << "CANNOT HANDLE MORE THAN FOUR ARGUMENTS YET!" << std::endl;
		}
	}
	Operand destination_label = Operand(OPERAND_TYPE_LABEL, 0, function_reference_to_symtab_entry->get_function_id());
	auto bl_function = new BranchLinkInstruction(destination_label, function_reference_to_symtab_entry);
	instr_list.push_back(bl_function);

	//handle returns if it exists
	if (function_reference_to_symtab_entry->get_return_type() == VARIABLE_TYPE_VOID) {
		//no return type
		output_operand = Operand(OPERAND_TYPE_UNDEFINED, 0);
        std::cout << "VOID EXP METHOD CALL\n" << std::endl;
        exit(1);
    } else {
		output_operand = Operand(OPERAND_TYPE_SYMBOLIC_REGISTER, (*symbolic_register_counter)++);
        auto move_output = new MoveInstruction(output_operand, Operand(OPERAND_TYPE_REGISTER, 0));
        instr_list.push_back(move_output);
	}

	has_generated_3AC = true;

	return instr_list;
}

Operand MethodCallExpASTNode::get_output_operand() {
	return output_operand;
}

int MethodCallExpASTNode::get_number_function_calls_in_children() {
	int n_function_calls = 1;
	for (auto exp : arg_exp_list) {
		n_function_calls += exp->get_number_function_calls_in_children();
	}
	return n_function_calls;
}

bool MethodCallExpASTNode::is_tmp_node() {
    return false;
}
